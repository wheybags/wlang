#include "Parser.hpp"
#include <optional>
#include <unordered_set>
#include "Assert.hpp"

// generated by grammar.py, transcribed to C++ manually
// Only including the ones we actually need (productions that can be Nil - ie we will need follows to know when to stop)
static std::unordered_set<Token::Type> FuncListPFollow = {Token::Type::End};
static std::unordered_set<Token::Type> ArgListPFollow = {Token::Type::CloseBracket};
static std::unordered_set<Token::Type> StatementListPFollow = {Token::Type::CloseBrace};
static std::unordered_set<Token::Type> ExpressionPFollow = {Token::Type::Semicolon, Token::Type::Assign};

class ParseContext
{
public:
  ParseContext(const Token* tokens, size_t size)
    : next(tokens)
    , remaining(size)
  {}

  const Token& peek()
  {
    release_assert(remaining > 0);
    return *next;
  }

  bool peekCheck(Token::Type type)
  {
    return peek().type == type;
  }

  const Token& pop()
  {
    release_assert(!empty());
    const Token* retval = next;
    next++;
    remaining--;
#ifndef NDEBUG
    popped = retval;
#endif
    return *retval;
  }

  bool popCheck(Token::Type type)
  {
    return pop().type == type;
  }

  bool empty() const
  {
    return remaining == 0;
  }

  Scope* getScope() { return scopeStack.back(); }
  void pushScope(Scope* scope) { scopeStack.push_back(scope); }
  void popScope() { scopeStack.pop_back(); }

private:
  std::vector<Scope*> scopeStack;
  const Token* next = nullptr;
  size_t remaining = 0;

#ifndef NDEBUG
  const Token* popped = nullptr;
#endif
};

Parser::Parser()
{
  for (const auto& name: {"i32", "bool"})
  {
    Type* type = makeNode<Type>();
    type->name = name;
    types[name] = type;
  }
}

const Root* Parser::parse(const std::vector<Token>& tokenStrings)
{
  ParseContext tokens(tokenStrings.data(), tokenStrings.size());
  return parseRoot(tokens);
}

template<typename T> T* Parser::makeNode()
{
  constexpr size_t blockSize = 256;
  if (nodeBlocks.empty() || nodeBlocks.back().size() == blockSize)
  {
    nodeBlocks.resize(nodeBlocks.size() + 1);
    nodeBlocks.back().reserve(blockSize);
  }

  NodeBlock& currentBlock = nodeBlocks.back();
  Node& node = currentBlock.emplace_back(T());
  return &std::get<T>(node);
}

Root* Parser::parseRoot(ParseContext& ctx)
{
  Root* rootNode = makeNode<Root>();
  rootNode->rootScope = makeNode<Scope>();
  ctx.pushScope(rootNode->rootScope);

  rootNode->funcList = parseFuncList(ctx);
  release_assert(ctx.popCheck(TT::End));
  return rootNode;
}


FuncList* Parser::parseFuncList(ParseContext& ctx)
{
  FuncList* funcList = makeNode<FuncList>();
  funcList->func = parseFunc(ctx);
  parseFuncListP(funcList, ctx);

  return funcList;
}

void Parser::parseFuncListP(FuncList* list, ParseContext& ctx)
{
  if (ctx.peekCheck(TT::Id))
  {
    list->next = parseFuncList(ctx);
  }
  else
  {
    // Nil
    release_assert(FuncListPFollow.count(ctx.peek().type));
  }
}

Func* Parser::parseFunc(ParseContext& ctx)
{
  Func* func = makeNode<Func>();
  func->returnType = parseType(ctx);
  func->name = parseId(ctx);
  release_assert(ctx.popCheck(TT::OpenBracket));
  parseFuncP(func, ctx);
  return func;
}

void Parser::parseFuncP(Func* func, ParseContext& ctx)
{
  if (ctx.peekCheck(TT::Id))
    func->argList = parseArgList(ctx);

  release_assert(ctx.popCheck(TT::CloseBracket));
  func->funcBody = parseBlock(ctx);
}

ArgList* Parser::parseArgList(ParseContext& ctx)
{
  ArgList* argList = makeNode<ArgList>();
  argList->arg = parseArg(ctx);
  parseArgListP(argList, ctx);
  return argList;
}

void Parser::parseArgListP(ArgList* argList, ParseContext& ctx)
{
  if (ctx.peekCheck(TT::Comma))
  {
    ctx.pop();
    argList->next = parseArgList(ctx);
  }
  else
  {
    // Nil
    release_assert(ArgListPFollow.count(ctx.peek().type));
  }
}

Arg* Parser::parseArg(ParseContext& ctx)
{
  Arg *arg = makeNode<Arg>();
  arg->type = parseType(ctx);
  arg->name = parseId(ctx);
  return arg;
}

Block* Parser::parseBlock(ParseContext& ctx)
{
  Block* block = makeNode<Block>();
  release_assert(ctx.popCheck(TT::OpenBrace));
  parseStatementList(block, ctx);
  release_assert(ctx.popCheck(TT::CloseBrace));
  return block;
}

void Parser::parseStatementList(Block* block, ParseContext& ctx)
{
  block->statements.push_back(parseStatement(ctx));
  release_assert(ctx.popCheck(TT::Semicolon));
  parseStatementListP(block, ctx);
}

void Parser::parseStatementListP(Block* block, ParseContext& ctx)
{
  if (ctx.peekCheck(TT::Return) || ctx.peekCheck(TT::Id))
  {
    parseStatementList(block, ctx);
  }
  else
  {
    // Nil
    release_assert(StatementListPFollow.count(ctx.peek().type));
  }
}

Statement* Parser::parseStatement(ParseContext& ctx)
{
  Statement* statement = makeNode<Statement>();
  if (ctx.peekCheck(TT::Return))
  {
    ctx.pop();
    ReturnStatement* returnStatement = makeNode<ReturnStatement>();
    returnStatement->retval = parseExpression(ctx);
    *statement = returnStatement;
  }
  else if(ctx.peekCheck(TT::Id))
  {
    Id* id = parseId(ctx);
    parseStatementP(id, statement, ctx);
  }
  else
  {

  }

  return statement;
}

void Parser::parseStatementP(Id* id, Statement* statement, ParseContext& ctx)
{
  if (ctx.peekCheck(TT::Id))
  {
    VariableDeclaration* variableDeclaration = makeNode<VariableDeclaration>();
    variableDeclaration->type = parseType(ctx, id);
    variableDeclaration->name = parseId(ctx);

//    auto it = ctx.getScope()->variables.find(variableDeclaration->name->name);
//    release_assert(it == ctx.getScope()->variables.end());
//    ctx.getScope()->variables.emplace_hint(it, variableDeclaration->name->name, variableDeclaration);

    *statement = variableDeclaration;
  }
  else if (ctx.peekCheck(TT::CompareEqual) || ctx.peekCheck(TT::Assign))
  {
    Assignment* assignment = makeNode<Assignment>();
    Expression* partial = makeNode<Expression>();
    *partial = id;
    assignment->left = parseExpressionP(partial, ctx);
    release_assert(ctx.popCheck(TT::Assign));
    assignment->right = parseExpression(ctx);
    *statement = assignment;
  }
  else
  {
    message_and_abort("bad statement");
  }
}

Expression* Parser::parseExpression(ParseContext& ctx)
{
  Expression* expression = makeNode<Expression>();

  if (ctx.peekCheck(TT::Id))
  {
    *expression = parseId(ctx);
    return parseExpressionP(expression, ctx);
  }
  else if (ctx.peekCheck(TT::Int32))
  {
    *expression = ctx.pop().i32Value;
    return parseExpressionP(expression, ctx);
  }
  else
  {
    message_and_abort("bad expression");
  }
}

Expression* Parser::parseExpressionP(Expression* partial, ParseContext& ctx)
{
  if (ctx.peekCheck(TT::CompareEqual))
  {
    ctx.pop();
    Expression* expression = makeNode<Expression>();
    CompareEqual* compareEqual = makeNode<CompareEqual>();
    compareEqual->left = partial;
    compareEqual->right = parseExpression(ctx);
    *expression = compareEqual;
    return expression;
  }
  else
  {
    // Nil
    release_assert(ExpressionPFollow.count(ctx.peek().type));
    return partial;
  }
}

Type* Parser::parseType(ParseContext& ctx, Id* fromId)
{
  const std::string* typeName = nullptr;

  if (fromId)
  {
    typeName = &fromId->name;
  }
  else
  {
    const Token& typeToken = ctx.pop();
    release_assert(typeToken.type == Token::Type::Id);
    typeName = &typeToken.idValue;
  }

  auto it = types.find(*typeName);

  if (it == types.end())
  {
    Type* type = makeNode<Type>();
    type->name = *typeName;
    types.emplace_hint(it, *typeName, type);
    return type;
  }
  else
  {
    return it->second;
  }
}

Id* Parser::parseId(ParseContext& ctx)
{
  Id *id = makeNode<Id>();
  release_assert(ctx.peek().type == Token::Type::Id);
  id->name = ctx.pop().idValue;
  return id;
}
